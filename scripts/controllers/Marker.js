// Generated by CoffeeScript 1.3.3
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(function(require, exports, module) {
    var $, Dialog, Marker, Raphael, Spine, delay, style;
    Spine = require('Spine');
    Raphael = require('Raphael');
    $ = require('jQuery');
    Dialog = require('zooniverse/controllers/Dialog');
    style = require('style');
    delay = require('util').delay;
    Marker = (function(_super) {

      __extends(Marker, _super);

      Marker.prototype.annotation = null;

      Marker.prototype.picker = null;

      Marker.prototype.label = null;

      Marker.prototype.labelText = null;

      Marker.prototype.deleteButton = null;

      Marker.prototype.labelRect = null;

      Marker.prototype.centerPoint = null;

      Marker.prototype.selected = false;

      function Marker() {
        this.destroy = __bind(this.destroy, this);

        this.lineBetween = __bind(this.lineBetween, this);

        this.stopPropagation = __bind(this.stopPropagation, this);

        this.dragEnd = __bind(this.dragEnd, this);

        this.centerCircleDrag = __bind(this.centerCircleDrag, this);

        this.dragStart = __bind(this.dragStart, this);

        this.deselect = __bind(this.deselect, this);

        this.select = __bind(this.select, this);

        this.render = __bind(this.render, this);

        this.onClickDelete = __bind(this.onClickDelete, this);

        this.hideLabel = __bind(this.hideLabel, this);

        this.showLabel = __bind(this.showLabel, this);

        this.drawLabel = __bind(this.drawLabel, this);

        this.askIfHalfVisible = __bind(this.askIfHalfVisible, this);

        this.checkForHalf = __bind(this.checkForHalf, this);
        Marker.__super__.constructor.apply(this, arguments);
        this.drawLabel();
        this.hideLabel();
        this.centerCircle = this.picker.paper.circle();
        this.centerCircle.attr(style.crossCircle);
        this.centerCircle.hover(this.showLabel, this.hideLabel);
        this.centerCircle.click(this.stopPropagation);
        this.centerCircle.drag(this.centerCircleDrag, this.dragStart, this.dragEnd);
        this.annotation.bind('change', this.render);
        this.annotation.bind('destroy', this.destroy);
        delay(this.checkForHalf);
      }

      Marker.prototype.checkForHalf = function() {
        var point, snappedToEdge, _i, _len, _ref;
        _ref = this.annotation.value.points;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          point = _ref[_i];
          if (point.x <= 0 || point.x >= 1) {
            snappedToEdge = true;
          }
          if (point.y <= 0 || point.y >= 1) {
            snappedToEdge = true;
          }
        }
        if (snappedToEdge) {
          return this.askIfHalfVisible();
        }
      };

      Marker.prototype.askIfHalfVisible = function() {
        var dialog,
          _this = this;
        return dialog = new Dialog({
          content: "Is at least half of that " + this.annotation.value.species + " visible in the image?",
          buttons: [
            {
              'Yes': true
            }, {
              'No': false
            }
          ],
          target: this.picker.classifier.el.parent(),
          className: 'classifier',
          done: function(halfInValue) {
            return _this.annotation.value.halfIn = halfInValue;
          }
        });
      };

      Marker.prototype.drawLabel = function(text) {
        var labelHeight;
        this.labelText = this.picker.paper.text();
        this.labelText.attr(style.label.text);
        this.labelText.transform('T20,0');
        labelHeight = (style.crossCircle.r * 2) + style.crossCircle['stroke-width'];
        this.deleteButton = this.picker.paper.rect(0, 0, labelHeight, labelHeight);
        this.deleteButton.attr(style.label.deleteButton);
        this.deleteButton.click(this.onClickDelete);
        this.deleteText = this.picker.paper.text(0, 0, '\u00D7');
        this.deleteText.attr(style.label.deleteButton.text);
        this.deleteText.click(this.onClickDelete);
        this.labelRect = this.picker.paper.rect(0, 0, 0, labelHeight);
        this.labelRect.toBack();
        this.labelRect.attr(style.label.rect);
        this.labelRect.transform("T0," + (-labelHeight / 2));
        this.label = this.picker.paper.set(this.labelText, this.labelRect, this.deleteButton, this.deleteText);
        return this.label.hover(this.showLabel, this.hideLabel);
      };

      Marker.prototype.showLabel = function() {
        this.dontHide = true;
        this.label.show();
        return this.label.animate({
          opacity: 1
        }, 100);
      };

      Marker.prototype.hideLabel = function() {
        var _this = this;
        delete this.dontHide;
        return delay(500, function() {
          if (!_this.dontHide) {
            return _this.label.animate({
              opacity: 0
            }, 100, function() {
              return _this.label.hide();
            });
          }
        });
      };

      Marker.prototype.onClickDelete = function() {
        return this.annotation.destroy();
      };

      Marker.prototype.render = function() {
        var textBox;
        if (this.annotation.destroyed || this.centerCircle.removed) {
          return;
        }
        this.labelText.attr({
          text: this.annotation.value.species.toUpperCase()
        });
        textBox = this.labelText.getBBox();
        this.labelRect.attr({
          width: 20 + Math.round(textBox.width) + 10
        });
        this.deleteButton.transform("T" + (this.labelRect.attr('width') - 1) + "," + (-style.crossCircle.r - (style.crossCircle['stroke-width'] / 2)));
        this.deleteText.transform("T" + (this.labelRect.attr('width') + 3) + ",-1}");
        this.labelRect.attr({
          fill: style[this.annotation.value.species]
        });
        return this.deleteButton.attr({
          fill: style[this.annotation.value.species]
        });
      };

      Marker.prototype.select = function() {
        this.selected = true;
        return this.trigger('select', this);
      };

      Marker.prototype.deselect = function() {
        this.selected = false;
        return this.trigger('deselect', this);
      };

      Marker.prototype.dragStart = function() {
        var point;
        if ($(this.centerCircle.node).closest(':disabled, .disabled').length !== 0) {
          return;
        }
        this.startPoints = (function() {
          var _i, _len, _ref, _results;
          _ref = this.annotation.value.points;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            point = _ref[_i];
            _results.push({
              x: point.x,
              y: point.y
            });
          }
          return _results;
        }).call(this);
        this.wasSelected = this.selected;
        if (!this.wasSelected) {
          return this.select();
        }
      };

      Marker.prototype.centerCircleDrag = function(dx, dy) {
        var h, i, point, w, _i, _len, _ref, _ref1;
        if (this.startPoints == null) {
          return;
        }
        this.moved = true;
        _ref = this.picker.getSize(), w = _ref.width, h = _ref.height;
        _ref1 = this.annotation.value.points;
        for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
          point = _ref1[i];
          point.x = ((this.startPoints[i].x * w) + dx) / w;
          point.y = ((this.startPoints[i].y * h) + dy) / h;
        }
        return this.annotation.trigger('change');
      };

      Marker.prototype.dragEnd = function() {
        if (this.wasSelected && !this.moved) {
          this.deselect();
        }
        if (this.moved) {
          this.checkForHalf();
        }
        delete this.startPoints;
        delete this.wasSelected;
        return delete this.moved;
      };

      Marker.prototype.stopPropagation = function(e) {
        return e.stopPropagation();
      };

      Marker.prototype.lineBetween = function(point1, point2) {
        if (!('x' in point1 && 'y' in point1)) {
          point1 = {
            x: point1.attr('cx'),
            y: point1.attr('cy')
          };
        }
        if (!('x' in point2 && 'y' in point2)) {
          point2 = {
            x: point2.attr('cx'),
            y: point2.attr('cy')
          };
        }
        return "M " + point1.x + " " + point1.y + " L " + point2.x + " " + point2.y;
      };

      Marker.prototype.destroy = function() {
        this.centerCircle.remove();
        return this.label.remove();
      };

      Marker.prototype.limit = function(value, threshold) {
        if ((0 - threshold < value && value < 0 + threshold)) {
          value = 0;
        }
        if ((1 - threshold < value && value < 1 + threshold)) {
          value = 1;
        }
        return value;
      };

      return Marker;

    })(Spine.Controller);
    return module.exports = Marker;
  });

}).call(this);
